export const VERTEX_SHADER:
    '\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n';
export const FRAGMENT_SHADER:
    '\nuniform sampler2D tex;\nuniform float texWidth;\nuniform float texHeight;\n\nuniform vec3 keyColor;\nuniform float similarity;\nuniform float smoothness;\nuniform float spill;\n\nvarying vec2 vUv;\n\n// From https://github.com/libretro/glsl-shaders/blob/master/nnedi3/shaders/rgb-to-yuv.glsl\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvec4 ProcessChromaKey(vec2 texCoord) {\n  vec4 rgba = texture2D(tex, texCoord);\n  float chromaDist = distance(RGBtoUV(texture2D(tex, texCoord).rgb), RGBtoUV(keyColor));\n\n  float baseMask = chromaDist - similarity;\n  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n  rgba.a = fullMask;\n\n  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.);\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n\n  return rgba;\n}\n\nvoid main(void) {\n  vec2 texCoord = vUv;\n  gl_FragColor = ProcessChromaKey(texCoord);\n}\n';
// # sourceMappingURL=constants.d.ts.map
